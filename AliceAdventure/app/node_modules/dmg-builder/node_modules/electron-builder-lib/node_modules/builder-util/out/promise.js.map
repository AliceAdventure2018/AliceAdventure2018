{"version":3,"file":"promise.js","sourceRoot":"","sources":["../src/promise.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,AAAO,AAAK,AAAM,AAAO,AAEzB,AAAM;;;;;;;;;;;;2BAA4B,AAAY;AAC5C,AAAO,UAAC,AAAK,MAAC,AAAK,iBAAC,AAAG,IAAC,CAAC,AAAK,MAAC,AAAK,SAAI,AAAK,AAAC,OAAC,AAAQ,AAAE,AAAC,AAAC;AAC3D,AAAO,UAAC,AAAI,KAAC,AAAC,AAAC,AACjB;AAAC,EAED,AAA6F,AAC7F,AAAM;;;AAAC,AAAK,8BAA4B,AAAmB,SAAE,AAA8C;AACzG,MAAI,AAAM,SAAa,AAAI;;AAC3B,MAAI,AAAC;AACH,AAAM,aAAG,MAAM,AAAO,AACxB;AAAC,IACD,AAAK,AAAC,OAAC,AAAa,AAAC,eAAC,AAAC;AACrB,QAAI,AAAC;AACH,YAAM,AAAI,KAAC,AAAI,AAAC,AAClB;AAAC,MACD,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,YAAM,IAAI,AAAW,YAAC,CAAC,AAAa,eAAE,AAAS,AAAC,AAAC,AACnD;AAAC;;AAED,UAAM,AAAa,AACrB;AAAC;;AAED,MAAI,AAAC;AACH,UAAM,AAAI,KAAC,AAAK,AAAC,AACnB;AAAC,IACD,AAAK,AAAC,OAAC,AAAS,AAAC,WAAC,AAAC;AACjB,UAAM,AAAS,AACjB;AAAC;;AACD,AAAM,SAAC,AAAM,AACf;AAAC,AAED,AAAM;;MAAmB,oBAAQ,AAAK;AACpC,cAAY,AAAoB,QAAE,UAAkB,AAAkB;AACpE,QAAI,AAAC,IAAG,AAAO;AACf,QAAI,AAAC,IAAG,AAAC;;AACT,AAAG,AAAC,SAAC,MAAM,AAAK,SAAI,AAAM,AAAC,QAAC,AAAC;AAC3B,YAAM,AAAM,AAAG,mBAAU,AAAC,AAAE,GAAG;AAC/B,AAAC,WAAI,AAAM,SAAG,AAAM,SAAG,AAAG,IAAC,AAAM,OAAC,AAAE,AAAC,MAAG,AAAI,OAAG,AAAM,MAAC,AAAK,AAC7D;AAAC;;AACD,AAAK,UAAC,AAAC,AAAC,AACV;AAAC,AACF,AAED,AAAM;;;;;;8BAAkC,AAAmB;AACzD,AAAM,SAAC,AAAgB,iBAAC,AAAO,SAAE,AAAI,AAAC,AACxC;AAAC,AAED,AAAM;;0BAA8B,AAAmB,SAAE,AAAgB;AACvE,AAAM,iBACH,AAAK,MAAC,AAAC,AAAC,AAAE;AACT,AAAE,AAAC,QAAC,AAAC,EAAC,AAAI,SAAK,AAAQ,YAAI,AAAC,EAAC,AAAI,SAAK,AAAS,AAAC,WAAC,AAAC;AAChD,AAAM,aAAC,AAAa,AACtB;AAAC;;AACD,UAAM,AAAC,AACT;AAAC,AAAC,AACN,GAPS,AAAO;AAOf","sourcesContent":["import chalk from \"chalk\"\n\nexport function printErrorAndExit(error: Error) {\n  console.error(chalk.red((error.stack || error).toString()))\n  process.exit(1)\n}\n\n// you don't need to handle error in your task - it is passed only indicate status of promise\nexport async function executeFinally<T>(promise: Promise<T>, task: (errorOccurred: boolean) => Promise<any>): Promise<T> {\n  let result: T | null = null\n  try {\n    result = await promise\n  }\n  catch (originalError) {\n    try {\n      await task(true)\n    }\n    catch (taskError) {\n      throw new NestedError([originalError, taskError])\n    }\n\n    throw originalError\n  }\n\n  try {\n    await task(false)\n  }\n  catch (taskError) {\n    throw taskError\n  }\n  return result\n}\n\nexport class NestedError extends Error {\n  constructor(errors: Array<Error>, message: string = \"Compound error: \") {\n    let m = message\n    let i = 1\n    for (const error of errors) {\n      const prefix = `Error #${i++} `\n      m += \"\\n\\n\" + prefix + \"-\".repeat(80) + \"\\n\" + error!.stack\n    }\n    super(m)\n  }\n}\n\nexport function orNullIfFileNotExist<T>(promise: Promise<T>): Promise<T | null> {\n  return orIfFileNotExist(promise, null)\n}\n\nexport function orIfFileNotExist<T>(promise: Promise<T>, fallbackValue: T): Promise<T> {\n  return promise\n    .catch(e => {\n      if (e.code === \"ENOENT\" || e.code === \"ENOTDIR\") {\n        return fallbackValue\n      }\n      throw e\n    })\n}"]}
